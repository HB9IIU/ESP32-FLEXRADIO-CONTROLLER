/*
  ESP32 -> SmartSDR CAT (Kenwood FA) + Optical Encoder (interrupt, smooth)
  + Preferences cache + IP auto-discover (cached -> default -> fast scan)

  - Tries cached IP first; if it fails, tries CAT_HOST.
  - If that fails, scans the local /24 for TCP 5002 and uses the first open host.
  - On successful connect, saves the IP for next boot.

  A -> GPIO32, B -> GPIO33
  Counts every edge via ISR; converts to detents (÷4) to avoid jitter.
  Gentle acceleration based on time between detents.

  Serial: 115200
*/

#include <WiFi.h>
#include <Preferences.h>

// ===== YOUR SETTINGS =====
const char* WIFI_SSID = "NO WIFI FOR YOU!!!";
const char* WIFI_PASS = "Nestle2010Nestle";
const IPAddress CAT_HOST(192,168,0,5);   // fallback if no cache / cache fails
const uint16_t  CAT_PORT = 5002;
// =========================

// --- discovery timeouts (keep it fast) ---
const uint32_t TCP_CONNECT_TIMEOUT_MS = 150;  // per quick probe attempt
const uint32_t SCAN_START_DELAY_MS    = 800;  // short pause before scanning
const uint8_t  SCAN_BREATHER_MS       = 6;    // tiny yield between probes

const int PIN_ENC_A = 32;   // Encoder A
const int PIN_ENC_B = 33;   // Encoder B

#define ENC_INPUT_MODE INPUT_PULLUP

// Base step per detent
const int32_t  STEP_HZ          = 1;    // 1 Hz per detent
const uint32_t SEND_INTERVAL_MS = 60;   // rate-limit CAT traffic
const uint32_t RESYNC_MS        = 800;  // periodic FA; poll (0=off)

// Acceleration thresholds (time between detents)
const uint32_t ACCEL_T1_MS = 35;  // <35ms → x4
const uint32_t ACCEL_T2_MS = 80;  // <80ms → x2

WiFiClient cat;
Preferences prefs;
IPAddress currentHost = CAT_HOST;

uint32_t vfoHz = 14110000;
uint32_t lastSentHz = vfoHz;

// ---------- Quadrature decoder (ISR) ----------
static const int8_t QDEC_TAB[16] = {
  0, -1, +1,  0,
 +1,  0,  0, -1,
 -1,  0,  0, +1,
  0, +1, -1,  0
};

volatile uint8_t  q_last = 0;      // last AB (bits: A<<1|B)
volatile int32_t  q_edges = 0;     // counts all edges (+/-1 per valid transition)
volatile uint32_t lastDetentMs = 0;
volatile int32_t  detentPending = 0;
volatile bool     needResetEncoderBaseline = false;

inline uint8_t fastReadAB() {
  return (uint8_t(digitalRead(PIN_ENC_A)) << 1) | uint8_t(digitalRead(PIN_ENC_B));
}

void IRAM_ATTR encISR() {
  uint8_t now = fastReadAB();
  uint8_t idx = (q_last << 2) | now;
  int8_t d = QDEC_TAB[idx];
  if (d != 0) {
    q_edges += d;
    detentPending += d;

    if (detentPending >= 4 || detentPending <= -4) {
      lastDetentMs = millis();
      detentPending = 0;
    }
  }
  q_last = now;
}

// ---------- Quick discovery helpers ----------
static bool tryConnectQuick(IPAddress host) {
  WiFiClient probe;
  bool ok = probe.connect(host, CAT_PORT, TCP_CONNECT_TIMEOUT_MS);
  probe.stop();
  return ok;
}

// Scan current /24, stop at first OPEN port 5002
static bool scanFirstOpen(IPAddress& found) {
  IPAddress me = WiFi.localIP();
  IPAddress net(me[0], me[1], me[2], 0);
  delay(SCAN_START_DELAY_MS);
  for (int last = 1; last <= 254; last++) {
    if (last == (int)me[3]) continue;
    IPAddress ip(net[0], net[1], net[2], last);
    if (tryConnectQuick(ip)) { found = ip; return true; }
    delay(SCAN_BREATHER_MS);
  }
  return false;
}

// ---------- Wi-Fi / CAT ----------
bool wifiConnect() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.println("[WiFi] Connecting...");
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 20000) {
    delay(250); Serial.print(".");
  }
  Serial.println();
  if (WiFi.status() == WL_CONNECTED) {
    Serial.print("[WiFi] IP: "); Serial.println(WiFi.localIP());
    return true;
  }
  Serial.println("[WiFi] FAILED");
  return false;
}

bool tryConnectHost(const IPAddress& host) {
  if (cat.connected()) cat.stop();
  delay(120);
  const uint16_t backoff[] = {600,1200,2000,3500};
  for (uint8_t i=0;i<4;i++) {
    Serial.printf("[CAT] Connecting %s:%u (try %u/4)\n",
      host.toString().c_str(), CAT_PORT, i+1);
    if (cat.connect(host, CAT_PORT, TCP_CONNECT_TIMEOUT_MS)) {
      cat.setNoDelay(true);
      cat.setTimeout(1200);
      Serial.println("[CAT] Connected.");
      return true;
    }
    delay(backoff[i]);
  }
  return false;
}

bool catConnect() {
  // 0) cached IP first
  String cached = prefs.getString("host", "");
  if (cached.length()) {
    IPAddress ip;
    if (ip.fromString(cached)) {
      Serial.printf("[CACHE] Trying cached host: %s\n", cached.c_str());
      if (tryConnectHost(ip)) { currentHost = ip; return true; }
      Serial.println("[CACHE] Cached host failed.");
    }
  }

  // 1) compiled default
  Serial.printf("[CAT] Trying default host: %s\n", CAT_HOST.toString().c_str());
  if (tryConnectHost(CAT_HOST)) { currentHost = CAT_HOST; return true; }

  // 2) subnet scan (fast)
  Serial.println("[SCAN] Scanning subnet for CAT (TCP 5002) ...");
  IPAddress found;
  if (scanFirstOpen(found)) {
    Serial.printf("[SCAN] Found CAT at %s\n", found.toString().c_str());
    if (tryConnectHost(found)) { currentHost = found; return true; }
  }

  Serial.println("[SCAN] No CAT found.");
  return false;
}

void saveCurrentHostIfNeeded() {
  String cached = prefs.getString("host", "");
  String nowStr = currentHost.toString();
  if (cached != nowStr) {
    prefs.putString("host", nowStr);
    Serial.printf("[SAVE] Stored CAT host: %s\n", nowStr.c_str());
  }
}

bool sendFA(uint32_t hz) {
  if (!cat.connected()) return false;
  char digits[16]; snprintf(digits, sizeof(digits), "%011u", hz);
  char cmd[24];    snprintf(cmd, sizeof(cmd), "FA%s;", digits);
  Serial.print(">> "); Serial.println(cmd);
  size_t n = cat.print(cmd);
  return (n == strlen(cmd));
}

bool readLine(String& out, uint32_t waitMs) {
  uint32_t t0 = millis();
  while (millis() - t0 < waitMs) {
    if (cat.available()) {
      String s = cat.readStringUntil(';');
      if (s.length()) { out = s + ';'; return true; }
    }
    delay(2); yield();
  }
  return false;
}

// Start at radio's current VFO (FA;)
bool initialSyncFromRadio() {
  if (!cat.connected()) return false;
  cat.print("FA;");
  String line;
  if (!readLine(line, 1500)) return false;
  if (!line.startsWith("FA") || line.length() < 14) return false;
  String d = line.substring(2, 13);
  vfoHz = (uint32_t)d.toInt();
  lastSentHz = vfoHz;
  noInterrupts(); q_edges = 0; detentPending = 0; q_last = fastReadAB(); interrupts();
  Serial.printf("[SYNC] Start at %.6f MHz\n", vfoHz/1e6);
  return true;
}

// Detect external FA changes
void pumpIncoming() {
  while (cat.connected() && cat.available()) {
    String s = cat.readStringUntil(';');
    if (!s.length()) break;
    s += ';';
    if (s == "?;") {
      Serial.println("<< ?; (ignored)");
    } else if (s.startsWith("FA") && s.length() >= 14) {
      String d = s.substring(2, 13);
      uint32_t rxHz = (uint32_t)d.toInt();
      Serial.print("<< "); Serial.println(s);
      if (rxHz != vfoHz) {
        vfoHz = rxHz;
        lastSentHz = rxHz;
        needResetEncoderBaseline = true;
        Serial.printf("[EXT] Radio → %.6f MHz (sync)\n", vfoHz/1e6);
      }
    } else {
      Serial.print("<< "); Serial.println(s);
    }
  }
}

// ---------- Arduino ----------
void setup() {
  Serial.begin(115200);
  delay(200);
  Serial.println("\n=== ESP32 Flex CAT + Encoder + Cache + Auto-Discover ===");

  prefs.begin("cat", false);  // RW namespace "cat"

  pinMode(PIN_ENC_A, ENC_INPUT_MODE);
  pinMode(PIN_ENC_B, ENC_INPUT_MODE);

  // Initialize last state and attach interrupts on BOTH pins
  q_last = fastReadAB();
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_A), encISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_B), encISR, CHANGE);

  if (!wifiConnect()) {
    Serial.println("[SYS] Rebooting (WiFi fail)...");
    delay(500);
    ESP.restart();
  }

  if (!catConnect()) {
    Serial.println("[CAT] Could not connect to CAT. Rebooting...");
    delay(500);
    ESP.restart();
  }

  saveCurrentHostIfNeeded();

  // Try to start from radio's current VFO; if not, push our local once
  if (!initialSyncFromRadio()) {
    Serial.println("[SYNC] No FA reply; pushing local once.");
    sendFA(vfoHz);
    lastSentHz = vfoHz;
  }
}

void loop() {
  if (cat.connected() && cat.available()) pumpIncoming();

  // reconnect if needed (currentHost first, then full catConnect sequence)
  static uint32_t lastTry = 0;
  if (!cat.connected() && millis() - lastTry > 1200) {
    lastTry = millis();
    if (!tryConnectHost(currentHost)) {
      if (!catConnect()) {
        Serial.println("[CAT] Reconnect failed; rebooting...");
        delay(500);
        ESP.restart();
      }
    }
    saveCurrentHostIfNeeded();
    if (!initialSyncFromRadio()) { sendFA(vfoHz); lastSentHz = vfoHz; }
  }

  // If radio changed externally, re-zero encoder delta once
  static bool cleared = false;
  if (needResetEncoderBaseline) {
    noInterrupts(); q_edges = 0; detentPending = 0; interrupts();
    needResetEncoderBaseline = false;
    cleared = true;
  } else {
    cleared = false;
  }

  // Convert edges to detents (÷4), apply step + gentle acceleration
  static int32_t lastEdges = 0;
  if (cleared) { noInterrupts(); lastEdges = q_edges; interrupts(); }

  int32_t edges; noInterrupts(); edges = q_edges; interrupts();
  int32_t deltaEdges = edges - lastEdges;

  int32_t detents = deltaEdges / 4;       // whole detents since last time
  lastEdges += detents * 4;               // keep remainder

  if (detents != 0) {
    uint32_t now = millis();
    uint32_t dt = now - lastDetentMs;

    int accel = 1;
    if      (dt < ACCEL_T1_MS) accel = 4;
    else if (dt < ACCEL_T2_MS) accel = 2;

    long next = (long)vfoHz + (long)detents * STEP_HZ * accel;
    if (next < 0) next = 0;
    vfoHz = (uint32_t)next;
  }

  // Rate-limited send
  static uint32_t lastSend = 0;
  if (cat.connected() && millis() - lastSend >= SEND_INTERVAL_MS) {
    lastSend = millis();
    if (vfoHz != lastSentHz) {
      if (sendFA(vfoHz)) lastSentHz = vfoHz;
      else if (cat.connected()) cat.stop();
    }
  }

  // Very light periodic FA; to notice mouse-driven changes
  static uint32_t lastFAq = 0;
  if (RESYNC_MS > 0 && cat.connected() && millis() - lastFAq > RESYNC_MS) {
    lastFAq = millis();
    cat.print("FA;");
  }

  delay(1);
}
