/*
  ESP32 -> SmartSDR CAT (Kenwood FA) + Encoders + Preferences + Auto-Discover
  + 5x TTP223 Touch Inputs (active-HIGH, idle LOW) with simple debounce
  + 2x Encoder Click Buttons (active-LOW with INPUT_PULLUP) with simple debounce

  TTP223 wiring:
  - VCC = 3.3V, GND = GND, OUT -> GPIO (18/19/21/22/23 here)
  - Pins are set to INPUT_PULLDOWN (idle LOW). Touch drives them HIGH.

  Encoder click buttons:
  - One side to GPIO (16 / 17), the other side to GND.
  - Pins use INPUT_PULLUP, so pressed = LOW.



  Touch1 = FT8 40m (7.074 MHz)
  Touch2 = FT8 20m (14.074 MHz)
  Freq Encoder Click = FT8 40m
  Vol  Encoder Click = FT8 20m
  Serial: 115200



*/

#include <WiFi.h>
#include <Preferences.h>

// ===== YOUR SETTINGS =====
const char *WIFI_SSID = "NO WIFI FOR YOU!!!";
const char *WIFI_PASS = "Nestle2010Nestle";
const IPAddress CAT_HOST(192, 168, 0, 5); // fallback if no cache / cache fails
const uint16_t CAT_PORT = 5002;
// =========================

// --- discovery timeouts (fast) ---
const uint32_t TCP_CONNECT_TIMEOUT_MS = 150;
const uint32_t SCAN_START_DELAY_MS = 800;
const uint8_t SCAN_BREATHER_MS = 6;

// --- LEDS ---
const int PIN_LED_GREEN = 13;
const int PIN_LED_RED = 4;

// ---- MAIN ENCODER (frequency) ----
const int PIN_ENC_A = 32;
const int PIN_ENC_B = 33;

// ---- FILTER ENCODER (preset 0..7) ----
const int PIN_FILT_A = 26;
const int PIN_FILT_B = 25;

// ---- VOLUME ENCODER ----
const int PIN_VOL_A = 14;
const int PIN_VOL_B = 27;

// ---- ENCODER CLICK BUTTONS (active-LOW with internal pull-ups) ----
const int PIN_ENC_BW_SW = 16;  // click of main (frequency) encoder
const int PIN_ENC_VOL_SW = 17; // click of volume encoder

// ---- VOLUME STEP (percent per detent) ----
const int VOLUME_STEP = 5; // change to 2/5/10 as you like

#define ENC_INPUT_MODE INPUT_PULLUP

// Frequency step/behavior
const int32_t STEP_HZ = 1;
const uint32_t SEND_INTERVAL_MS = 60;
const uint32_t RESYNC_MS = 800;
const uint32_t ACCEL_T1_MS = 35;
const uint32_t ACCEL_T2_MS = 80;

// ---- FT8 frequencies (Hz) ----
const uint32_t FT8_40M_HZ = 7077000UL;  // 7.074 MHz normally but i wat to hear LSB (just to see if teher is activity)
const uint32_t FT8_20M_HZ = 14074000UL; // 14.074 MHz

// ---- TTP223 TOUCH PINS (active-HIGH, idle LOW) ----
const int PIN_TOUCH1 = 23;
const int PIN_TOUCH2 = 22;
const int PIN_TOUCH3 = 21;
const int PIN_TOUCH4 = 19;
const int PIN_TOUCH5 = 18;

// Simple debounce
const uint16_t TOUCH_DEBOUNCE_MS = 50;
bool touchLast1 = false, touchLast2 = false, touchLast3 = false, touchLast4 = false, touchLast5 = false;
uint32_t touchT1 = 0, touchT2 = 0, touchT3 = 0, touchT4 = 0, touchT5 = 0;

// Encoder click debounce (active-LOW)
const uint16_t CLICK_DEBOUNCE_MS = 50;
bool clickLastBW = false, clickLastVol = false; // "pressed" state (LOW) after inversion
uint32_t clickTBW = 0, clickTVol = 0;

WiFiClient cat;
Preferences prefs;
IPAddress currentHost = CAT_HOST;

uint32_t vfoHz = 14110000, lastSentHz = vfoHz;

// ---------- Quadrature decoder (ISR) : MAIN ----------
static const int8_t QDEC_TAB[16] = {
    0, -1, +1, 0, +1, 0, 0, -1, -1, 0, 0, +1, 0, +1, -1, 0};

volatile uint8_t q_last = 0;
volatile int32_t q_edges = 0;
volatile uint32_t lastDetentMs = 0;
volatile int32_t detentPending = 0;
volatile bool needResetEncoderBaseline = false;

inline uint8_t fastReadAB()
{
  return (uint8_t(digitalRead(PIN_ENC_A)) << 1) | uint8_t(digitalRead(PIN_ENC_B));
}

void IRAM_ATTR encISR()
{
  uint8_t now = fastReadAB();
  uint8_t idx = (q_last << 2) | now;
  int8_t d = QDEC_TAB[idx];
  if (d)
  {
    q_edges += d;
    detentPending += d;
    if (detentPending >= 4 || detentPending <= -4)
    {
      lastDetentMs = millis();
      detentPending = 0;
    }
  }
  q_last = now;
}

// ---------- FILTER ENCODER ----------
volatile uint8_t f_q_last = 0;
volatile int32_t f_edges = 0;
int8_t filterIdx = 0; // 0..7

inline uint8_t fastReadAB_filt()
{
  return (uint8_t(digitalRead(PIN_FILT_A)) << 1) | uint8_t(digitalRead(PIN_FILT_B));
}

void IRAM_ATTR filtISR()
{
  uint8_t now = fastReadAB_filt();
  uint8_t idx = (f_q_last << 2) | now;
  int8_t d = QDEC_TAB[idx];
  if (d)
    f_edges += d;
  f_q_last = now;
}
// ---- LED helpers ----
inline void ledsOff()
{
  digitalWrite(PIN_LED_GREEN, LOW);
  digitalWrite(PIN_LED_RED, LOW);
}
inline void ledGreenSolid()
{
  digitalWrite(PIN_LED_GREEN, HIGH);
  digitalWrite(PIN_LED_RED, LOW);
}
inline void ledRedSolid()
{
  digitalWrite(PIN_LED_GREEN, LOW);
  digitalWrite(PIN_LED_RED, HIGH);
}

// Blink RED/GREEN alternately for durationMs (used instead of blocking delays)
void blinkAlt(uint32_t durationMs, uint16_t periodMs = 150)
{
  uint32_t t0 = millis();
  bool phase = false;
  while (millis() - t0 < durationMs)
  {
    // phase=false -> RED on, GREEN off; phase=true -> GREEN on, RED off
    digitalWrite(PIN_LED_RED, phase ? LOW : HIGH);
    digitalWrite(PIN_LED_GREEN, phase ? HIGH : LOW);
    phase = !phase;
    delay(periodMs); // replaces the old blocking delay(...)
  }
  ledsOff(); // stop blinking after the timed window
}

// --- non-blocking GREEN flash state ---
bool redFlashActive = false;
uint32_t redFlashUntil = 0;

// Call this to flash RED for ms (default ~120 ms)
inline void flashRedLed(uint16_t ms = 120)
{
  redFlashActive = true;
  redFlashUntil = millis() + ms;
  digitalWrite(PIN_LED_RED, HIGH); // start flash
}

// ---------- VOLUME ENCODER ----------
volatile uint8_t v_q_last = 0;
volatile int32_t v_edges = 0;
int16_t volumePct = 50; // 0..100

inline uint8_t fastReadAB_vol()
{
  return (uint8_t(digitalRead(PIN_VOL_A)) << 1) | uint8_t(digitalRead(PIN_VOL_B));
}

void IRAM_ATTR volISR()
{
  uint8_t now = fastReadAB_vol();
  uint8_t idx = (v_q_last << 2) | now;
  int8_t d = QDEC_TAB[idx];
  if (d)
    v_edges += d;
  v_q_last = now;
}

// ---------- Discovery helpers ----------
static bool tryConnectQuick(IPAddress host)
{
  WiFiClient probe;
  bool ok = probe.connect(host, CAT_PORT, TCP_CONNECT_TIMEOUT_MS);
  probe.stop();
  return ok;
}

static bool scanFirstOpen(IPAddress &found)
{
  IPAddress me = WiFi.localIP();
  IPAddress net(me[0], me[1], me[2], 0);
  delay(SCAN_START_DELAY_MS);
  for (int last = 1; last <= 254; last++)
  {
    if (last == (int)me[3])
      continue;
    IPAddress ip(net[0], net[1], net[2], last);
    if (tryConnectQuick(ip))
    {
      found = ip;
      return true;
    }
    delay(SCAN_BREATHER_MS);
  }
  return false;
}

// ---------- Wi-Fi / CAT ----------
bool wifiConnect()
{
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.println("[WiFi] Connecting...");

  // start: green off, blink red
  digitalWrite(PIN_LED_GREEN, LOW);
  bool redState = false;
  uint32_t t0 = millis();
  uint32_t lastBlink = 0;

  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 20000)
  {
    if (millis() - lastBlink >= 200)
    { // blink every 200 ms
      lastBlink = millis();
      redState = !redState;
      digitalWrite(PIN_LED_RED, redState);
    }
    delay(10);
  }

  // stop blinking
  digitalWrite(PIN_LED_RED, LOW);

  if (WiFi.status() == WL_CONNECTED)
  {
    Serial.print("[WiFi] IP: ");
    Serial.println(WiFi.localIP());
    return true;
  }
  else
  {
    Serial.println("[WiFi] FAILED");
    digitalWrite(PIN_LED_RED, HIGH); // solid red = failed (will reboot)
    return false;
  }
}

bool tryConnectHost(const IPAddress &host)
{
  if (cat.connected())
    cat.stop();
  delay(120);

  const uint16_t backoff[] = {600, 1200, 2000, 3500};

  for (uint8_t i = 0; i < 4; i++)
  {
    // show a quick alternating blink to indicate an active attempt
    digitalWrite(PIN_LED_RED, HIGH);
    digitalWrite(PIN_LED_GREEN, LOW);
    delay(120);
    digitalWrite(PIN_LED_RED, LOW);
    digitalWrite(PIN_LED_GREEN, HIGH);
    delay(120);
    ledsOff();

    Serial.printf("[CAT] Connecting %s:%u (try %u/4)\n",
                  host.toString().c_str(), CAT_PORT, i + 1);

    if (cat.connect(host, CAT_PORT, TCP_CONNECT_TIMEOUT_MS))
    {
      cat.setNoDelay(true);
      cat.setTimeout(1200);
      Serial.println("[CAT] Connected.");
      ledGreenSolid(); // ✅ solid green when CAT is up
      return true;
    }

    // connection failed -> alternate-blink during backoff window
    blinkAlt(backoff[i]); // ⏳ replaces delay(backoff[i])
  }

  // all tries failed
  ledRedSolid(); // ❌ solid red (you reboot after this anyway)
  return false;
}

bool catConnect()
{
  String cached = prefs.getString("host", "");
  if (cached.length())
  {
    IPAddress ip;
    if (ip.fromString(cached))
    {
      Serial.printf("[CACHE] Trying cached host: %s\n", cached.c_str());
      if (tryConnectHost(ip))
      {
        currentHost = ip;
        return true;
      }
      Serial.println("[CACHE] Cached host failed.");
    }
  }
  Serial.printf("[CAT] Trying default host: %s\n", CAT_HOST.toString().c_str());
  if (tryConnectHost(CAT_HOST))
  {
    currentHost = CAT_HOST;
    return true;
  }

  Serial.println("[SCAN] Scanning subnet for CAT (TCP 5002) ...");
  IPAddress found;
  if (scanFirstOpen(found))
  {
    Serial.printf("[SCAN] Found CAT at %s\n", found.toString().c_str());
    if (tryConnectHost(found))
    {
      currentHost = found;
      return true;
    }
  }
  Serial.println("[SCAN] No CAT found.");
  return false;
}

void saveCurrentHostIfNeeded()
{
  String cached = prefs.getString("host", "");
  String nowStr = currentHost.toString();
  if (cached != nowStr)
  {
    prefs.putString("host", nowStr);
    Serial.printf("[SAVE] Stored CAT host: %s\n", nowStr.c_str());
  }
}

bool readLine(String &out, uint32_t waitMs)
{
  uint32_t t0 = millis();
  while (millis() - t0 < waitMs)
  {
    if (cat.available())
    {
      String s = cat.readStringUntil(';');
      if (s.length())
      {
        out = s + ';';
        return true;
      }
    }
    delay(2);
    yield();
  }
  return false;
}

bool sendFA(uint32_t hz)
{
  if (!cat.connected())
    return false;
  char digits[16];
  snprintf(digits, sizeof(digits), "%011u", hz);
  char cmd[24];
  snprintf(cmd, sizeof(cmd), "FA%s;", digits);
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

// ----- Filter preset (ZZFI) -----
bool sendFilterPreset(uint8_t idx)
{
  if (!cat.connected())
    return false;
  if (idx > 7)
    idx = 7;
  char cmd[16];
  snprintf(cmd, sizeof(cmd), "ZZFI%02u;", idx);
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

void readFilterPresetOnce()
{
  if (!cat.connected())
    return;
  cat.print("ZZFI;");
  String line;
  if (readLine(line, 800) && line.startsWith("ZZFI") && line.endsWith(";") && line.length() >= 6)
  {
    filterIdx = line.substring(4, line.length() - 1).toInt();
    if (filterIdx < 0)
      filterIdx = 0;
    if (filterIdx > 7)
      filterIdx = 7;
    Serial.printf("[FILTER] Current preset = %d\n", filterIdx);
  }
  else
  {
    Serial.println("[FILTER] No reply; defaulting to 0");
    filterIdx = 0;
  }
}

// ----- Volume (Flex ZZAGnnn; 000..100) -----
bool setVolumeA(uint8_t lvl)
{
  if (!cat.connected())
    return false;
  if (lvl > 100)
    lvl = 100;
  char cmd[16];
  snprintf(cmd, sizeof(cmd), "ZZAG%03u;", lvl);
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

int readVolumeA()
{ // 0..100 or -1
  if (!cat.connected())
    return -1;
  cat.print("ZZAG;");
  String line;
  if (!readLine(line, 800))
    return -1; // expect "ZZAGnnn;"
  if (!line.startsWith("ZZAG") || !line.endsWith(";"))
    return -1;
  return line.substring(4, line.length() - 1).toInt();
}

// ----- Sync VFO from radio -----
bool initialSyncFromRadio()
{
  if (!cat.connected())
    return false;
  cat.print("FA;");
  String line;
  if (!readLine(line, 1500))
    return false;
  if (!line.startsWith("FA") || line.length() < 14)
    return false;
  String d = line.substring(2, 13);
  vfoHz = (uint32_t)d.toInt();
  lastSentHz = vfoHz;
  noInterrupts();
  q_edges = 0;
  detentPending = 0;
  q_last = fastReadAB();
  interrupts();
  Serial.printf("[SYNC] Start at %.6f MHz\n", vfoHz / 1e6);
  return true;
}

// ----- Incoming CAT pump -----
void pumpIncoming()
{
  while (cat.connected() && cat.available())
  {
    String s = cat.readStringUntil(';');
    if (!s.length())
      break;
    s += ';';
    if (s == "?;")
    {
      Serial.println("<< ?; (ignored)");
    }
    else if (s.startsWith("FA") && s.length() >= 14)
    {
      String d = s.substring(2, 13);
      uint32_t rxHz = (uint32_t)d.toInt();
      Serial.print("<< ");
      Serial.println(s);
      if (rxHz != vfoHz)
      {
        vfoHz = rxHz;
        lastSentHz = rxHz;
        needResetEncoderBaseline = true;
        Serial.printf("[EXT] Radio → %.6f MHz (sync)\n", vfoHz / 1e6);
      }
    }
    else
    {
      Serial.print("<< ");
      Serial.println(s);
    }
  }
}

// ====== SIMPLE ACTIONS ======
void setFrequencyHz(uint32_t hz)
{
  vfoHz = hz;
  if (cat.connected())
  {
    if (sendFA(vfoHz))
      lastSentHz = vfoHz;
    else
    {
      Serial.println("[CAT] Send failed; stopping socket.");
      cat.stop();
    }
  }
  needResetEncoderBaseline = true;
  Serial.printf("[ACTION] VFO set to %.6f MHz\n", vfoHz / 1e6);
}

// --- implementation (place with your CAT helpers)
static int mdCodeFromString(String m)
{
  m.toUpperCase();
  if (m == "LSB")
    return 1;
  if (m == "USB")
    return 2;
  if (m == "CW")
    return 3;
  if (m == "FM")
    return 4; // NFM/DFM/FDV family
  if (m == "AM" || m == "SAM")
    return 5;
  if (m == "DIGL" || m == "RTTY")
    return 6;
  if (m == "DIGU")
    return 9;
  return -1;
}

bool setMode(const String &mode)
{
  if (!cat.connected())
    return false;
  int code = mdCodeFromString(mode);
  if (code < 0)
  {
    Serial.printf("[MD] Unknown mode '%s'\n", mode.c_str());
    return false;
  }
  char cmd[12];
  snprintf(cmd, sizeof(cmd), "MD%d;", code);
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

int getMode()
{ // reads current mode (MDn) -> n
  if (!cat.connected())
    return -1;
  cat.print("MD;");
  String line;
  if (!readLine(line, 800))
    return -1; // expect "MDn;"
  if (!line.startsWith("MD") || !line.endsWith(";"))
    return -1;
  return line.substring(2, line.length() - 1).toInt();
}

bool setPTT(bool on)
{
  if (!cat.connected())
    return false;
  const char *cmd = on ? "ZZTX1;" : "ZZTX0;";
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

// Cleanly close CAT + Wi-Fi before rebooting (very small + safe)
inline void cleanCloseNet() {
  if (cat.connected()) {
    cat.stop();         // closes TCP with FIN
    delay(50);
  }
  WiFi.disconnect(true, true);  // drop STA and forget current link
  delay(100);
}



// --- prototypes
void setFT8_40m() { setFrequencyHz(FT8_40M_HZ); }
void setFT8_20m() { setFrequencyHz(FT8_20M_HZ); }
void rebootESP();
bool setPTT(bool on);
bool setMode(const String &mode);
int getMode();                 // returns MD code or -1 on fail
bool setPowerPct(uint8_t pct); // ZZPC 000..100
int getPowerPct();             // 0..100 or -1
bool setModeCode(int code);    // send MDn; directly

void startTune(uint16_t ms = 1200, uint8_t tunePower = 10, const String &tuneMode = "AM");
void serviceTune(); // call from loop()

// --- RF Power via ZZPC (SmartSDR CAT)
bool setPowerPct(uint8_t pct)
{
  if (!cat.connected())
    return false;
  if (pct > 100)
    pct = 100;
  char cmd[12];
  snprintf(cmd, sizeof(cmd), "ZZPC%03u;", pct);
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

int getPowerPct()
{ // returns 0..100 or -1 on fail
  if (!cat.connected())
    return -1;
  cat.print("ZZPC;");
  String line;
  if (!readLine(line, 800))
    return -1; // expect "ZZPCnnn;"
  if (!line.startsWith("ZZPC") || !line.endsWith(";"))
    return -1;
  return line.substring(4, line.length() - 1).toInt();
}

// --- Mode by code (MDn;) so we can restore without mapping back to a string
bool setModeCode(int code)
{
  if (!cat.connected())
    return false;
  char cmd[12];
  snprintf(cmd, sizeof(cmd), "MD%d;", code);
  Serial.print(">> ");
  Serial.println(cmd);
  return cat.print(cmd) == (int)strlen(cmd);
}

// ---- TUNE state ----
bool tuneActive = false;
uint32_t tuneUntilMs = 0;
int savedModeCode = -1;
int savedPowerPct = -1;

void startTune(uint16_t ms, uint8_t tunePower, const String &tuneMode)
{
  if (tuneActive || !cat.connected())
    return;

  // snapshot current settings
  savedModeCode = getMode();     // MD?;
  savedPowerPct = getPowerPct(); // ZZPC?;
  if (savedModeCode < 0)
    savedModeCode = -1;
  if (savedPowerPct < 0)
    savedPowerPct = -1;

  // prep carrier: set AM (or your choice) and low drive
  setMode(tuneMode);
  setPowerPct(tunePower);

  // key MOX
  setPTT(true);
  digitalWrite(PIN_LED_RED, HIGH); // show TX

  tuneUntilMs = millis() + ms;
  tuneActive = true;
}

void serviceTune()
{
  if (!tuneActive)
    return;
  if ((int32_t)(millis() - tuneUntilMs) < 0)
    return;

  // time’s up: unkey and restore
  setPTT(false);
  digitalWrite(PIN_LED_RED, LOW);

  if (savedModeCode >= 0)
    setModeCode(savedModeCode);
  if (savedPowerPct >= 0)
    setPowerPct((uint8_t)savedPowerPct);

  tuneActive = false;
}

// ---------- Arduino ----------
void setup()
{
  Serial.begin(115200);

  delay(200);
  Serial.println("\n=== ESP32 Flex CAT + Encoders + Auto-Discover + TTP223 Touch + Clicks ===");

  prefs.begin("cat", false);

  // Main encoder
  pinMode(PIN_ENC_A, ENC_INPUT_MODE);
  pinMode(PIN_ENC_B, ENC_INPUT_MODE);
  q_last = fastReadAB();
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_A), encISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_ENC_B), encISR, CHANGE);

  // Filter encoder
  pinMode(PIN_FILT_A, ENC_INPUT_MODE);
  pinMode(PIN_FILT_B, ENC_INPUT_MODE);
  f_q_last = fastReadAB_filt();
  attachInterrupt(digitalPinToInterrupt(PIN_FILT_A), filtISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_FILT_B), filtISR, CHANGE);

  // Volume encoder
  pinMode(PIN_VOL_A, ENC_INPUT_MODE);
  pinMode(PIN_VOL_B, ENC_INPUT_MODE);
  v_q_last = fastReadAB_vol();
  attachInterrupt(digitalPinToInterrupt(PIN_VOL_A), volISR, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PIN_VOL_B), volISR, CHANGE);

  // Encoder click buttons (active-LOW with pull-ups)
  pinMode(PIN_ENC_BW_SW, INPUT_PULLUP);
  pinMode(PIN_ENC_VOL_SW, INPUT_PULLUP);
  clickLastBW = !digitalRead(PIN_ENC_BW_SW); // pressed = LOW -> !LOW = true
  clickLastVol = !digitalRead(PIN_ENC_VOL_SW);

  // TTP223 touch pins: INPUT_PULLDOWN (idle LOW, touch = HIGH)
  pinMode(PIN_TOUCH1, INPUT_PULLDOWN);
  pinMode(PIN_TOUCH2, INPUT_PULLDOWN);
  pinMode(PIN_TOUCH3, INPUT_PULLDOWN);
  pinMode(PIN_TOUCH4, INPUT_PULLDOWN);
  pinMode(PIN_TOUCH5, INPUT_PULLDOWN);

  // LEDs
  pinMode(PIN_LED_GREEN, OUTPUT);
  pinMode(PIN_LED_RED, OUTPUT);
  ledsOff();
  // Init debounce baselines
  touchLast1 = digitalRead(PIN_TOUCH1);
  touchLast2 = digitalRead(PIN_TOUCH2);
  touchLast3 = digitalRead(PIN_TOUCH3);
  touchLast4 = digitalRead(PIN_TOUCH4);
  touchLast5 = digitalRead(PIN_TOUCH5);
  uint32_t now = millis();
  touchT1 = touchT2 = touchT3 = touchT4 = touchT5 = now;
  clickTBW = clickTVol = now;

  if (!wifiConnect())
  {
    Serial.println("[SYS] Rebooting (WiFi fail)...");
    delay(500);
    ESP.restart();
  }
  if (!catConnect())
  {
    Serial.println("[CAT] Could not connect to CAT. Rebooting...");
    delay(500);
    ESP.restart();
  }

  saveCurrentHostIfNeeded();

  if (!initialSyncFromRadio())
  {
    Serial.println("[SYNC] No FA reply; pushing local once.");
    sendFA(vfoHz);
    lastSentHz = vfoHz;
  }

  // Init filter + volume from radio
  readFilterPresetOnce();
  int v = readVolumeA();
  if (v >= 0)
  {
    volumePct = v;
    Serial.printf("[VOL] %d%%\n", volumePct);
  }
}

void loop()
{
  if (cat.connected() && cat.available())
    pumpIncoming();

  // reconnect if needed
  static uint32_t lastTry = 0;
  if (!cat.connected() && millis() - lastTry > 1200)
  {
    lastTry = millis();
    if (!tryConnectHost(currentHost))
    {
      if (!catConnect())
      {
        Serial.println("[CAT] Reconnect failed; rebooting...");
        delay(500);
        ESP.restart();
      }
    }
    saveCurrentHostIfNeeded();
    if (!initialSyncFromRadio())
    {
      sendFA(vfoHz);
      lastSentHz = vfoHz;
    }
    readFilterPresetOnce();
    int v = readVolumeA();
    if (v >= 0)
      volumePct = v;
  }

  // External change sync baseline
  static int32_t lastEdges = 0;
  if (needResetEncoderBaseline)
  {
    noInterrupts();
    q_edges = 0;
    detentPending = 0;
    interrupts();
    needResetEncoderBaseline = false;
    noInterrupts();
    lastEdges = q_edges;
    interrupts();
  }

  // MAIN ENCODER: freq detents + accel
  int32_t edges;
  noInterrupts();
  edges = q_edges;
  interrupts();
  int32_t deltaEdges = edges - lastEdges;
  int32_t detents = deltaEdges / 4;
  if (detents != 0)
  {
    lastEdges += detents * 4;
    uint32_t nowMs = millis();
    uint32_t dt = nowMs - lastDetentMs;
    int accel = 1;
    if (dt < ACCEL_T1_MS)
      accel = 4;
    else if (dt < ACCEL_T2_MS)
      accel = 2;
    long next = (long)vfoHz + (long)detents * STEP_HZ * accel;
    if (next < 0)
      next = 0;
    vfoHz = (uint32_t)next;
  }

  // Rate-limited FA
  static uint32_t lastSend = 0;
  if (cat.connected() && millis() - lastSend >= SEND_INTERVAL_MS)
  {
    lastSend = millis();
    if (vfoHz != lastSentHz)
    {
      if (sendFA(vfoHz))
        lastSentHz = vfoHz;
      else if (cat.connected())
        cat.stop();
    }
  }

  // Light periodic FA;
  static uint32_t lastFAq = 0;
  if (RESYNC_MS > 0 && cat.connected() && millis() - lastFAq > RESYNC_MS)
  {
    lastFAq = millis();
    cat.print("FA;");
  }

  // FILTER ENCODER: 4 edges = 1 detent; step 0..7
  static int32_t f_lastEdges = 0;
  int32_t fe;
  noInterrupts();
  fe = f_edges;
  interrupts();
  int32_t f_delta = fe - f_lastEdges;
  int32_t f_detents = f_delta / 4;
  if (f_detents != 0)
  {
    f_lastEdges += f_detents * 4;
    int8_t dir = (f_detents > 0) ? +1 : -1;
    int8_t newIdx = filterIdx + dir;
    if (newIdx < 0)
      newIdx = 0;
    if (newIdx > 7)
      newIdx = 7;
    if (newIdx != filterIdx)
    {
      filterIdx = newIdx;
      sendFilterPreset((uint8_t)filterIdx);
    }
  }

  // VOLUME ENCODER: each detent = VOLUME_STEP %, clamp 0..100, throttle sends
  static int32_t v_lastEdges = 0;
  static uint32_t lastVolSend = 0;
  static int16_t lastVolSent = -1;

  int32_t ve;
  noInterrupts();
  ve = v_edges;
  interrupts();
  int32_t v_delta = ve - v_lastEdges;
  int32_t v_detents = v_delta / 4;
  if (v_detents != 0)
  {
    v_lastEdges += v_detents * 4;
    int16_t newVol = volumePct + (int16_t)v_detents * VOLUME_STEP;
    if (newVol < 0)
      newVol = 0;
    if (newVol > 100)
      newVol = 100;
    volumePct = newVol;
  }
  if (cat.connected() && volumePct != lastVolSent && millis() - lastVolSend >= 120)
  {
    if (setVolumeA((uint8_t)volumePct))
    {
      lastVolSent = volumePct;
      lastVolSend = millis();
    }
  }

  // ===== SIMPLE TOUCH HANDLING (active-HIGH, debounced) =====
  uint32_t t = millis();

  bool r1 = digitalRead(PIN_TOUCH1);
  if (r1 != touchLast1 && (t - touchT1) >= TOUCH_DEBOUNCE_MS)
  {
    touchLast1 = r1;
    touchT1 = t;
    if (r1)
    {
      Serial.println("[TTP] 1 -> FT8 40m; mode: LSB");
      flashRedLed();
      setFT8_40m();
      setMode("LSB");
    }
  }
  bool r2 = digitalRead(PIN_TOUCH2);
  if (r2 != touchLast2 && (t - touchT2) >= TOUCH_DEBOUNCE_MS)
  {
    touchLast2 = r2;
    touchT2 = t;
    if (r2)
    {
      Serial.println("[TTP] 2 -> FT8 20m; mode: USB");
      flashRedLed();
      setFT8_20m();
      setMode("USB");
    }
  }
  bool r3 = digitalRead(PIN_TOUCH3);
  if (r3 != touchLast3 && (t - touchT3) >= TOUCH_DEBOUNCE_MS)
  {
    touchLast3 = r3;
    touchT3 = t;
    if (r3)
    { // finger down
      Serial.println("[TTP] 3 -> PTT ON");
      setPTT(true);
      digitalWrite(PIN_LED_RED, HIGH);
    }
    else
    { // finger up
      Serial.println("[TTP] 3 -> PTT OFF");
      setPTT(false);
      digitalWrite(PIN_LED_RED, LOW);
    }
  }
  bool r4 = digitalRead(PIN_TOUCH4);
  if (r4 != touchLast4 && (t - touchT4) >= TOUCH_DEBOUNCE_MS)
  {
    touchLast4 = r4;
    touchT4 = t;
    if (r4)
    {
      Serial.println("[TTP] 4 pressed -> TUNE");
      flashRedLed();
      startTune(/*ms*/ 1200, /*power%*/ 10, /*mode*/ "FM");
    }
  }
  bool r5 = digitalRead(PIN_TOUCH5);
  if (r5 != touchLast5 && (t - touchT5) >= TOUCH_DEBOUNCE_MS)
  {
    touchLast5 = r5;
    touchT5 = t;
    if (r5)
    {
      Serial.println("[TTP] 5 pressed (no action)");
      flashRedLed();
    }
  }

  // ===== ENCODER CLICK HANDLING (active-LOW, debounced) =====
  bool cfRaw = !digitalRead(PIN_ENC_BW_SW); // pressed if LOW
  if (cfRaw != clickLastBW && (t - clickTBW) >= CLICK_DEBOUNCE_MS)
  {
    clickLastBW = cfRaw;
    clickTBW = t;
    if (cfRaw)
    {
      Serial.println("[CLICK] BW");
      rebootESP();
    }
  }

  bool cvRaw = !digitalRead(PIN_ENC_VOL_SW); // pressed if LOW
  if (cvRaw != clickLastVol && (t - clickTVol) >= CLICK_DEBOUNCE_MS)
  {
    clickLastVol = cvRaw;
    clickTVol = t;
    if (cvRaw)
    {
      Serial.println("[CLICK] Vol -> FT8 20m");
      setFT8_20m();
    }
  }
  if (redFlashActive && (int32_t)(millis() - redFlashUntil) >= 0)
  {
    redFlashActive = false;
    digitalWrite(PIN_LED_RED, LOW); // end flash
  }

  serviceTune();

  delay(1);
}

void rebootESP()
{
cleanCloseNet();
  // fast blink RED 5 times (about 0.8s total)
  for (int i = 0; i < 5; ++i) {
    digitalWrite(PIN_LED_GREEN, LOW);
    digitalWrite(PIN_LED_RED, HIGH);
    delay(80);
    digitalWrite(PIN_LED_RED, LOW);
    delay(80);
  }
  ESP.restart();
}

